# State

## State パターン
Stateパターンでは「状態」というものをクラスとして表現する。状態をクラスとして表現していれば、クラスを切り替えることによって「状態変化」が表せ、新しい状態を追加しなければならないときに何をプログラムすればよいかがはっきりする。  

### Stateパターンを使わない疑似コーディング

```
public class Microwave {

    private String curState = 'waiting';

    public void start(){
        if (curState == 'waiting') {
            System.out.println("Microwave is working, Please wait ...");
            curState = 'working';
        }else if (curState == 'working') {
            System.out.println("Microwave is already working");
        }
    }

    public void pause() {
        if (curState == 'waiting') {
            // process
        }else if (curState == 'working') {
            // process
        }
    }
}
```

Stateパターンを使わない場合では、各メソッドの中のif文のところに登場し、各メソッド内で現在の状態を調べている。  
一方、Stateパターンを使う場合では、 **状態がクラスとして表現** されている。状態がクラスとして表現されているので、その中のメソッドには、もはや **状態チェックのためのif文は登場しない** 。

## Sample Code Running

```
$ cd src
$ javac state/Main.java
$ java state.Main
Microwave is working, Please wait ...
The microwave is paused
The microwave is stopped
The microwave is not working already
Microwave is working, Please wait ...
The microwave is paused
The microwave is resumed
The microwave is stopped
```

## State パターンの登場人物
### State (状態)の役
State役は、状態を表すためのものである。状態ごとに異なる振る舞いをするインターフェース(API)を定める。このインターフェース(API)は、 **状態に依存した振る舞いをするメソッドの集まり** になる。  
サンプルプログラムでは、`State`インターフェースがこの役をつとめている。  

### ConcreteState(具体的な状態)の役
ConcreteState役は、具体的な個々の状態を表現するものである。State役で定められたインターフェース(API)を具体的に実装する。  
サンプルプログラムでは、`WaitingState`, `WorkingState`, `PausedState`がこの役をつとめている。  

### Context(状況、前後関係、文脈)の役
Context役は、現在の状態を表すConcreteState役を持つ。また、Stateパターンの利用者に必要なインターフェース(API)を定める。  
サンプルプログラムでは、`Microwave`クラスがこの役をつとめている。  

## 考えを広げるためのヒント
### 分割して統治せよ
分割して統治せよ(divide and conquer)という方針は、プログラミングによく登場する。これは複雑で大規模なものを取り扱う場合の方針である。大きくてややこしい問題をは、そのまま解こうとしてはいけない。その問題をまず小さな問題に分ける。それでもまだ解きにくかったら、さらに小さな問題にして分けなさい。問題は、簡単に解けるまで小さくしてから解きなさい。大きくてややこしい問題を1つ解く代わりに、小さくてややこしい問題をたくさん解きなさい。・・・分割して統治せよ、というのは、簡単にいえばそういうことである。  

Stateパターンでは、「状態」というクラスで表現した。個々の具体的な状態を、別々のクラスとして表現して、問題を分割したのである。1つのConcreteState役のクラスをコーディングしている最中、プログラマは、他のクラスのことを(ある程度)頭から追い出すことができる。  
前述の *Stateパターンを使わない疑似コーディング* において、Stateパターンを使わないと、呼び出されるメソッドの中で、現在の状態に応じた条件分岐が発生する。状態が多くなればなるほど、この条件分岐が増えていくことになる。しかも、同じような条件分岐は、出来ごとが起こったときに呼び出されるメソッド全部に書く必要がある。  
Stateパターンは、システムの「状態」をクラスとして表現することで、複雑なプログラムを分割している。  

### 状態遷移は誰が管理すべきか
Stateパターンを使う場合、 **状態遷移は誰が管理すべきか** という点には注意するように。  
状態遷移の管理を行うのは、`Context`役か、`ConcreteState`役のどちらかである。サンプルプログラムは、前者であり、`Context`役である`Microwave`を各`ConcreteState`役へ委譲させることで、状態遷移を行っている。このやり方では、個々のConcreteState役の独立性が高まり、プログラム全体の見通しがよくなる場合がある。しかし、この場合は、Context役がすべてのConcreteState役を知らなければならなくなる。  
また、`ConcreteState`役に状態遷移の管理を任せる場合、  
良い点は、「他の状態に遷移するのはいつか」という情報が、1つのクラス内にまとまっている点。  
悪い点は、「1つのConcreteState役が、他のConcreteState役を知らなければならない」という点である。  

あるいはまた、Stateパターンの代わりに状態のテーブル(表)を使って設計するてもある。テーブルは、「入力と内部状態」を元に「出力と次の内部状態」が得られるような一覧表になる。状態遷移が固定的なルールにもとづいている場合には、このようなテーブルを使ったプログラムも有効といえる。  
さらに、状態数が多い場合には、手で書くのをやめ、プログラムを自動生成する別のプログラムを使う方法もある。

### 自己矛盾が起こらない
Stateパターンを使わず、システムの状態が複数の変数の値の集合で表現されているとする。そのとき、変数の値の間に自己矛盾や不整合があってはならない。
Stateパターンでは、状態をクラスで表現する。現在の状態を表す変数は、たった1つである。サンプルプログラムでは、`Microwave`クラスの`curState`フィールドである。このため、自己矛盾をはらんだ状態というのが存在しないことが保証される。

### 新しい状態を追加するのは簡単だが・・・
Stateパターンに新しい状態を追加するのは簡単である。`State`インターフェースを実装した`XXXState`クラスを作り、必要なメソッドを実装すればよいためである。もちろん、状態遷移の部分は注意深くコーディングする必要がある。状態遷移の部分こそが、他のConcreteState役との接点になるためである。  
しかし、出来上がっているStateパターンに、新しい「状態依存の処理(start, stop, pauseの他にということ)」を追加するのは困難である。それは、State役のインターフェースにメソッドを追加することを意味し、すべてのConcreteState役に処理を追加することになるからである。  
困難ではあるが、しかし、メソッドの追加をうっかり忘れる危険はない。例えば、サンプルプログラムの`State`インターフェースに`shutdown`というメソッドを追加したとする。`WaitingState`, `WorkingState`, `PausedState`クラスでそのメソッドを実装し忘れたとすると、ソースをコンパイルするときに「メソッドが実装されていない」というエラーになるからである。  
もしStateパターンを使っていなかったら、どうなるか。Stateパターンを使っていない場合、状態を考慮するのはif文の中の条件式である。そのため、「この状態について実装忘れがあるよ」というエラーを **コンパイル時に** 検出するのは非常に困難になる。( **実行時に** 検出するのはそれほど難しくはない。考慮していない状態を検出したらエラーにするというコーディングを、各メソッドの中に前もって行っておけばよいからである。)

## 関連しているパターン
### Singletonパターン
ConcreteState役は、Singletonパターンとして実装される場合がある。

### Flyweightパターン
状態を表すクラスはインスタンスフィールドを持たない。そのため、Flyweightパターンを使って、ConcreteState役を複数のContextで共有できる場合もある。
