## Adapter

### Adapterパターン
すでに提供されているものがそのまま使えないときに、必要な形に変換してから利用することがよくある。「すでに提供されているもの」と「必要なもの」の間のズレを埋めるようなデザインパターンが、  
**Adapterパターン**
である。
AdapterパターンはWrappterパターンとも呼ばれる

### サンプルプログラム01 *object* version
*委譲*をつかっている
> Javaでの委譲とは、あるメソッドの処理を他のインスタンスのメソッドに任せてしまうということ。

```実行
$ javac adapter/object/Main.java
$ java adapter.object.main
Dog is runnning
Kangaroo is jumping
```

### サンプルプログラム02 *interface* version

### Adapterパターンの登場人物
##### Target(対象)の役
いま必要となっているメソッドを定めている役。サンプルプログラム01では、`Animal`インターフェースがこの役をつとめた。
##### Client(依頼者)の役
Target役のメソッドを使って仕事をする役。サンプルプログラム01では、`Main`がこの役をつとめた
##### Adaptee(適合される側)の役
Adapteeはすでに用意されているメソッドを持っている役。サンプルプログラム01では`Knagaroo`がこの役をつとめた
##### Adapterの役
サンプルプログラム01では`KangarooAdapter`がこの役をつとめた

### 考えを広げるためのヒント
#### どんなときに使うのか
すでに存在しているクラスを利用することもよくあります。特にそのクラスが十分にテストされ、バグが少なく、また実際にこれまで使われてきた実績があるのならば、なおさら。なんとかそのクラスを部品として再利用したいもの。  
Adapterパターンは、既存のクラスに一皮かぶせて必要とするクラスを作る。このパターンによって、必要とするメソッド群をすばやく作ることができる。もしバグが出たとしても、既存のクラス(Adaptee役)にはバグがないことがわかっているので、Adapter役のクラスを重点的に調べればよいことになり、プログラムのチェックがとても楽になる。

#### たとえソースがなくても
すでに作られたクラスがあって、新しいインターフェース(API)に適合させる、と考えるとAdapterパターンというのは当たり前のように感じられるが、私たちは、新しいインターフェース(API)に適合させようとするとき、つい、既存のクラスのソースをいじって「修正」しようと考えてしまう。しかし、それでは、動作テストが既に済んでいる既存のクラスを、修正後もう一度テストしなければならなくなる。  
Adapterパターンは、既存のクラスには全く手を加えずに、目的のインターフェース(API)にあわせようとするものである。

#### バージョンアップと互換性
バージョンメンテナンスにもAdapterパターンは使える

#### かけ離れたクラス
当然、Adapter役とTarget役の機能があまりにもかけ離れていると、Adapterパターンは使えない。交流100ボルトの電源を元にして直流12ボルトにはできるが、水道の水を出すわけにはいかないことと同じ。

#### 関連しているパターン
##### Bridgeパターン
Adapterパターンは、インターフェース(API)が異なっているクラス同士を結びつけるパターン。Bridgeパターンは、機能の階層と実装の階層を結びつけるパターンである。

##### Decoratorパターン
Decoratorパターンは、APIを変えずに機能を追加するパターンである。
